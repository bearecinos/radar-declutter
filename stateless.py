# Expect to find 2 files
# maps.npz with heightmap, aspect and scope in
# info.txt with data such as corner coordinates and cell size
# IN FUTURE: could store other data in info.txt such as for modelling
import math
import numpy as np
import os
import viewshed
from time import clock

#_pointx, _pointy = 469900.0, 3095000.0
#_above_ground, _isOffset = 100.0, True
#_PATH, _antennaDir = "point2", None

#_cropWidth, _cropHeight = 210, 210
_RANGE = 3000.0
_SetupRun = False
_NODATA = -100000


def Setup(maps="maps.npz",info="info.txt"): 
    """Loads the full numpy arrays to be cropped for each point."""
    global _fullHeightmap, _fullSlope, _fullAspect , _SetupRun, low, left, _CellSize, _cropSize

    try:
        arrays = np.load(maps)
    except IOError:
        print "Error in stateless.py, failed to load: "+maps
        print "Please check this is the correct filename and that it is in the current directory."
        print "This should contain the array data for the area, generated by Generate.storeRasters()"
        return -1
    _fullHeightmap = arrays["heightmap"].astype(float)
    _fullSlope = arrays["slope"].astype(float)
    _fullAspect = arrays["aspect"].astype(float)

    try:
        with open(info,"r") as f:
            data = f.read().split(",")
            left = float(data[0])
            low = float(data[1])
            _CellSize = float(data[2])
    except IOError:
        print "Failed to load: "+info
        print "Please check this is the correct filename and that it is in the current directory."
        print "This should contain the metadata for the arrays of the area, generated by Generate.storeRasters()"
        return -1
    _cropSize = int(2.0*_RANGE/_CellSize) + 10 # padding to avoid rounding cropping out cells
    _SetupRun = True
    return 0

# creates npArray of compass direction to all visible points
def _getDirections(vis,pointx,pointy,cropLeft,cropLow):
    """Calculates the bearing from the radar to each visible point on the raster."""
    directions = np.full_like(vis,_NODATA,float)
    y,x = np.indices(vis.shape) 
    directions[vis==1] = 180.0/math.pi * np.arctan2(pointx-cropLeft-_CellSize*x[vis==1], pointy-cropLow-(_cropSize-y[vis==1]-1)*_CellSize)+180
    return directions

def _mcos(x):
    return math.cos(math.radians(x))
def _msin(x):
    return math.sin(math.radians(x))

# generates map of incidence angle for all visible surfaces
def _makeIncidence(vis,elevation,heightmap,trueDist,distances,slope,aspect,directions):
    """Generates the incidence angle from the radar for each point of the raster. Final array is in radians."""
    incidence = np.full_like(vis,_NODATA,float)
    m = (vis==1)
    cosTheta = (elevation-heightmap[m])/trueDist[m]
    sinTheta = distances[m]/trueDist[m]
    cosAng = cosTheta * np.cos(math.pi/180.0*slope[m]) - sinTheta * np.sin(np.pi/180.0*slope[m]) * np.cos(math.pi/180.0*(directions[m]-aspect[m]))
    
    incidence[m] = np.arccos(cosAng) # if errors - caused by FP errors in cosAng
    return incidence


# generates map of 3d distance to visible surfaces from 2d distance + height difference
def _makeDistance(vis,distances,heightmap,elevation):
    """Generates the 3D distance from the radar to each point of the raster."""
    trueDist = np.full_like(vis,_NODATA,float)
    trueDist[vis==1] = (distances[vis==1]**2+(heightmap[vis==1]-elevation)**2)**0.5
    return trueDist

def _makeDist2D(vis,pointx,pointy,cropLeft,cropLow):
    """Calculates the xy distance to each visible point on the raster, ignoring differences in height."""
    distances = np.full_like(vis,_NODATA,float)

    y,x = np.indices(vis.shape) 
    distances[vis==1] = ((pointx - cropLeft - _CellSize*x[vis==1])**2 + (pointy - cropLow - _CellSize*y[vis==1])**2)**0.5
    
    return distances

def _makeAntenna(vis,heightmap,elevation,trueDist,directions,distances,antennaDir):
    # finds theta and phi for spherical system where direction antenna points is z-axis
    # expecting directivity to only depend on theta
    # assume antenna level, pointing in direction antennaDir
    """ Generate theta and phi for a spherical coordinate system with the antenna along the z-axis. Result is in radians."""
    m = (vis==1)
    worldTheta = np.arccos((heightmap[m]-elevation)/trueDist[m]) # angle from vertical down to point
    worldPhi = ((directions[m]-antennaDir)%360)*math.pi/180.0 # angle antenna would turn to point closest

    theta = np.full_like(vis,_NODATA,float)
    phi = np.full_like(vis,_NODATA,float)
    theta[m] = np.arccos(np.sin(worldTheta)*np.cos(worldPhi))
    phi[m] = np.arctan2(distances[m]*np.sin(worldPhi),heightmap[m]-elevation)

    return theta,phi

def generateMaps(pointx,pointy,path,above_ground=100.0,isOffset=True,antennaDir=None):
    """Produces rasters for which points are visible, their distance and incidence angles to the radar, and optionally antenna orientation data.
    Parameters:
    pointx float : x-coordinate of point.
    pointy float : y-coordinate of point.
    path string : name of folder to save data in.
    above_ground float (optional) : Either actual altitude of radar or elevation above ground. Default = 100.0.
    isOffset boolean (optional) : Indicates the given 'above_ground' is relative to the ground. Default = True.
    antennaDir float (optional) : The direction the radar was facing in degrees. By default, not used.    
    """
    if not _SetupRun:
        if Setup():
            return -1
    
    # rounds down the corner
    pointCoords = [int((pointx-left)/_CellSize),int((pointy-low)/_CellSize)]
    
    height = _fullHeightmap.shape[0]
    # stop at edges, end up with point no longer in center - affects coordinates of point in grid.
    # in y direction lower index is greater y position
    upper, lower = max(0,height-pointCoords[1]-_cropSize/2), min(height,height-pointCoords[1]+_cropSize/2)
    l, r = max(0,pointCoords[0]-_cropSize/2), min(height,pointCoords[0]+_cropSize/2)

    cropLeft = left + l*_CellSize
    cropLow = low + (height-1-lower)*_CellSize
    
    heightmap = _fullHeightmap[upper:lower,l:r]
    slope = _fullSlope[upper:lower,l:r]
    aspect = _fullAspect[upper:lower,l:r]
    cropHeight,cropWidth = heightmap.shape
    
    pointCoords = np.array([(pointx-cropLeft)/_CellSize,(pointy-cropLow)/_CellSize])
    groundHeight = viewshed.quadHeight(heightmap,np.array([pointCoords[0]]),np.array([cropHeight-1.0-pointCoords[1]]))

    if groundHeight == _NODATA:
        # not above mapped ground so don't generate anything
        # could still generate if not isOffset but still wouldn't have full map
        return 0

    try:
        os.makedirs(path)
    except OSError:
        print "Error in stateless.py, couldn't make directory, likely already exists."
        print "Please rename the direcory '"+path+"' or use a different path."
        return -1
  
    vis = viewshed.viewshed(heightmap,(pointx-cropLeft)/_CellSize, (pointy-cropLow)/_CellSize,above_ground,isOffset,gridsize=_CellSize)
    
    if isOffset:
        elevation = groundHeight+above_ground
    else:
        elevation = above_ground
        above_ground = elevation - groundHeight

    distances = _makeDist2D(vis,pointx,pointy,cropLeft,cropLow)
    directions = _getDirections(vis,pointx,pointy,cropLeft,cropLow)

    trueDist = _makeDistance(vis,distances,heightmap,elevation)
    
    incidence = _makeIncidence(vis,elevation,heightmap,trueDist,distances,slope,aspect,directions)

    if antennaDir is not None:
        theta, phi = _makeAntenna(vis,heightmap,elevation,trueDist,directions,distances,antennaDir)
        np.savez_compressed(path+"/arrays.npz",visible=vis,distance=trueDist,
                            incidence=incidence,antennaTheta=theta,antennaPhi=phi) 
    else:
        np.savez_compressed(path+"/arrays.npz",visible=vis,distance=trueDist,
                            incidence=incidence)   

    # stores coordinates, z being against reference and elevation being above ground
    with open(path+"/x_y_z_elevation","w") as f:
        f.write(str(pointx)+","+str(pointy)+","+str(elevation)+","+str(above_ground))
    return 0
    
if __name__=="__main__" and False:
    if Setup():
        print "Failed"
    else:
        import matplotlib.pyplot as plt
        generateMaps(469900.0, 3095000.0,"point1")
